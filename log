ft_isalpha:    [OK] 
ft_isdigit:    [OK] 
ft_isalnum:    [OK] 
ft_isascii:    [OK] 
ft_isprint:    [OK] 
ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memset:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_bzero:      [OK] [OK] [OK] [OK] 
ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] 
[crash]: your memcpy does not behave well with NULL as both params with size
Test code:
	ft_memcpy(((void *)0), ((void *)0), 3);


ft_memmove:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] [OK] 
[crash]: your memmove does not well with NULL as both parameters and size
Test code:
	ft_memmove(((void *)0), ((void *)0), 5);


ft_strlcpy:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcat:    [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] 
[fail]: your strlcat does not work with basic input
Test code:
	char *str = "the cake is a lie !\0I'm hidden lol\r\n";
	char buff1[0xF00] = "there is no stars in the sky";
	char buff2[0xF00] = "there is no stars in the sky";
	size_t max = strlen("the cake is a lie !\0I'm hidden lol\r\n") + 4;
	size_t r1 = __builtin___strlcat_chk (buff1, str, max, __builtin_object_size (buff1, 2 > 1 ? 1 : 0));
	size_t r2 = ft_strlcat(buff2, str, max);

	if (r1 != r2)
		exit(TEST_FAILED);
	char s1[4] = "";
	char s2[4] = "";
	r1 = __builtin___strlcat_chk (s1, "thx to ntoniolo for this test !", 4, __builtin_object_size (s1, 2 > 1 ? 1 : 0))
		;
	r2 = ft_strlcat(s2, "thx to ntoniolo for this test !", 4)
		;
	if (r1 != r2)
		exit(TEST_FAILED);
	exit(TEST_SUCCESS);

Diffs:
     strlcat: |42|
  ft_strlcat: |47|

[fail]: your strlcat return value is false
Test code:
	char *src = "aaa";
	char dst1[20];
	char dst2[20];
	int ret1;
	int ret2;

	__builtin___memset_chk (dst1, 'B', sizeof(dst1), __builtin_object_size (dst1, 0));
	__builtin___memset_chk (dst2, 'B', sizeof(dst2), __builtin_object_size (dst2, 0));
	__builtin___strlcat_chk (dst1, src, 20, __builtin_object_size (dst1, 2 > 1 ? 1 : 0));
	__builtin___strlcat_chk (dst1, src, 20, __builtin_object_size (dst1, 2 > 1 ? 1 : 0));
	ret1 = __builtin___strlcat_chk (dst1, src, 20, __builtin_object_size (dst1, 2 > 1 ? 1 : 0));
	ft_strlcat(dst2, src, 20);
	ft_strlcat(dst2, src, 20);
	ret2 = ft_strlcat(dst2, src, 20);
	if (ret1 == ret2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strlcat: |23|
  ft_strlcat: |24|

ft_toupper:    [OK] 
ft_tolower:    [OK] 
ft_strchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strrchr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strncmp:    [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] 
[fail]: your strncmp does not cast in unsigned char the diff
Test code:
	char *s1 = "\200";
	char *s2 = "\0";
	int i1 = ((strncmp(s1, s2, 1) > 0) ? 1 : ((strncmp(s1, s2, 1) < 0) ? -1 : 0));
	int i2 = ((ft_strncmp(s1, s2, 1) > 0) ? 1 : ((ft_strncmp(s1, s2, 1) < 0) ? -1 : 0));

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncmp: |1|
  ft_strncmp: |-1|

[fail]: your strncmp does not work with non ascii chars
Test code:
	char *s1 = "\x12\xff\x65\x12\xbd\xde\xad";
	char *s2 = "\x12\x02";
	size_t size = 6;
	int i1 = ((strncmp(s1, s2, size) > 0) ? 1 : ((strncmp(s1, s2, size) < 0) ? -1 : 0));
	int i2 = ((ft_strncmp(s1, s2, size) > 0) ? 1 : ((ft_strncmp(s1, s2, size) < 0) ? -1 : 0));

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strncmp: |1|
  ft_strncmp: |-1|

ft_memchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memcmp:     [OK] [OK] [FAILED] [OK] [OK] [FAILED] [FAILED] [OK] [OK] [OK] 
[fail]: your memcmp does not work with basic input
Test code:
	char *s1 = "\xff\xaa\xde\x12";
	char *s2 = "\xff\xaa\xde\x12MACOSAAAAA";
	size_t size = 4;
	int i1 = simple_memcmp(s1, s2, size);
	int i2 = ft_memcmp(s1, s2, size);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      memcmp: |0|
   ft_memcmp: |-77|

[fail]: your memcmp stop at \0
Test code:
	char *s1 = "atoms\0\0\0\0";
	char *s2 = "atoms\0abc";
	size_t size = 8;
	int i1 = simple_memcmp(s1, s2, size);
	int i2 = ft_memcmp(s1, s2, size);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      memcmp: |-97|
   ft_memcmp: |0|

[fail]: your memcmp does not work with basic input
Test code:
	char *s1 = "\xff\0\0\xaa\0\xde\xffMACOSX\xff";
	char *s2 = "\xff\0\0\xaa\0\xde\x00MBS";
	size_t size = 9;
	int i1 = simple_memcmp(s1, s2, size);
	int i2 = ft_memcmp(s1, s2, size);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
      memcmp: |255|
   ft_memcmp: |0|

ft_strnstr:    [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [OK] [NO CRASH] [OK] 
[fail]: your strnstr does not work with basic input
Test code:
	char *s1 = "MZIRIBMZIRIBMZE123";
	char *s2 = "MZIRIBMZE";
	size_t max = strlen(s2);
	char *i1 = strnstr(s1, s2, max);
	char *i2 = ft_strnstr(s1, s2, max);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strnstr: |(null)|
  ft_strnstr: |MZIRIBMZE123|

[fail]: your strnstr does not work with empty strings and 0 length
Test code:
	char *s1 = "oh no not the empty string !";
	char *s2 = "";
	size_t max = 0;
	char *i1 = strnstr(s1, s2, max);
	char *i2 = ft_strnstr(s1, s2, max);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strnstr: |oh no not the empty string !|
  ft_strnstr: |(null)|

[no crash]: your strnstr does not segfault when null parameter is sent
Test code:
	ft_strnstr("fake", ((void *)0), 3);


ft_atoi:       [OK] [OK] [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
[fail]: your atoi is not working with blanks
Test code:
	char *n = "\t\v\f\r\n \f-06050";
	int i1 = atoi(n);
	int i2 = ft_atoi(n);

	if (i1 == i2)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
        atoi: |-6050|
     ft_atoi: |0|

ft_calloc:     [OK] [OK] [OK] [FAILED] [OK] 
[fail]: your calloc don't work with 0 size
Test code:
	void *str = ft_calloc(0, 0);

	if (str == ((void *)0))
		exit(TEST_FAILED);
	free(str);
	exit(TEST_SUCCESS);

Diffs:


ft_strdup:     [OK] [OK] [OK] [OK] [OK] [OK] [NO CRASH] 
[no crash]: your strdup does not segv with NULL parameter
Test code:
	ft_strdup(((void *)0));


ft_substr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [FAILED] 
[fail]: your substr does not work when start >= ft_strlen(s)
Test code:
	char *str = "01234";
	size_t size = 10;
	char *ret = ft_substr(str, 10, size);

	if (!strncmp(ret, "", 1))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
      substr: ||
   ft_substr: | strjoin d|

ft_strjoin:    [OK] [OK] [OK] [OK] [OK] 
ft_strtrim:    [OK] [OK] [OK] [CRASH] [CRASH] [OK] [OK] [OK] [OK] 
[crash]: your strtrim does not work with full blank input
Test code:
	char *s1 = "  \t \t \n   \n\n\n\t";
	char *s2 = "";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[crash]: your strtrim does not work with empty input
Test code:
	char *s1 = "";
	char *s2 = "";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_split:      [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_itoa:       [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strmapi:    [OK] [OK] [OK] [OK] [OK] 
ft_striteri:   [OK] [OK] 
ft_putchar_fd: [OK] [OK] 
ft_putstr_fd:  [OK] [OK] 
ft_putendl_fd: [OK] [OK] 
ft_putnbr_fd:  [OK] [OK] [OK] [OK] [OK] 
ft_lstnew:     [OK] [OK] [CRASH] [OK] 
[crash]: your lstnew does not work with null parameter
Test code:
	t_list *l = ft_lstnew(((void *)0));

	if (!l->content)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_lstadd_front: [OK] [OK] [OK] 
ft_lstsize:    [OK] [OK] 
ft_lstlast:    [OK] [CRASH] 
[crash]: your lstlast does not work with basic input
Test code:
	t_list *l = ((void *)0);
	t_list *expected;
	t_list *actual;

	expected = ((void *)0);
	actual = ft_lstlast(l);
	if (actual == expected)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


ft_lstadd_back:[OK] [OK] [OK] 
ft_lstdelone:  [OK] 
ft_lstclear:   [OK] [OK] [OK] 
ft_lstiter:    [OK]
